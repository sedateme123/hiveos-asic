#!/hive/sbin/bash


#
# Copyright (C) 2017  Hiveon Holding LTD
# Distributed under Business Source License 1.1
# License information can be found in the LICENSE.txt file or at https://github.com/minershive/hiveos-asic/blob/master/LICENSE.txt
#
# Linted by shellcheck 0.7.0
#


readonly script_mission='Client for ASICs: Antminer overclock profiles management'
readonly script_version='0.7.8'
readonly script_basename="${0##*/}"
readonly script_DEBUG="${script_DEBUG:-1}" # use value from env if exists


# !!! bash strict mode, no unbound variables
set -o nounset


#
# functions
#

function die {
	# !!! must be the first line in this function to catch the incoming error code -- do not move
	local -r incoming_exitcode=$?

	# args
	local -r message="$1"
	local -r exitcode="${2:-$incoming_exitcode}"

	# code
	[[ -n "$message" ]] && echo "${BRED}${script_basename}:${NOCOLOR} $message"
	exit "$exitcode"
} 1>&2

function print_script_usage {
	# code
	echo "Usage: ${CYAN-}${script_basename} 'JSON profile string' [-f|--force]${NOCOLOR-}"
	echo "       ${CYAN-}${script_basename} status [OPTIONS]${NOCOLOR-}"
	echo "       ${CYAN-}${script_basename} default|factory${NOCOLOR-}"
	echo "       ${CYAN-}${script_basename} re-tune|retune [full]${NOCOLOR-}"
	echo "       ${CYAN-}${script_basename} finetune${NOCOLOR-}"
	echo "       ${CYAN-}${script_basename} clear-cache [profile_id...]${NOCOLOR-}"
	echo
	echo "   ${WHITE-}-f, --force${GRAY-}                  forced apply -- ignore cache for this profile${NOCOLOR-}"
	echo "   ${WHITE-}-j, --json${GRAY-}                   generate JSON with active profile and list of cached profiles${NOCOLOR-}"
	echo "   ${WHITE-}-d, --active-profile-desc${GRAY-}    prints description of the active profile${NOCOLOR-}"
	echo "   ${WHITE-}-i, --active-profile-id${GRAY-}      prints ID of the active profile${NOCOLOR-}"
	echo "   ${WHITE-}-l, --cached-profiles-list${GRAY-}   lists IDs of all cached profiles${NOCOLOR-}"
	echo
}

function process_arguments {
	# vars
	local active_profile
	local -a cached_profiles_array

	# code
	case "${1-}" in
		'clear-cache')
			print_script_version
			# shellcheck disable=SC2207
			# ...bc care is taken to have word splitting work the right way + way simplier error handling
			if cached_profiles_array=( $( get_cached_profiles_ids ) ) && (( ${#cached_profiles_array[@]} > 0 )); then
				# at least one profile is cached
				echo "Cached profiles found: $( print_array_comma_separated 'cached_profiles_array' )"
				echo
				if (( ${#@} > 1 )); then
					# do clear only selected profile(s)
					clear_cached_profile "${@:2}"
				else
					# do clear all cached profiles
					clear_cached_profile 'ALL'
				fi
			else
				# shellcheck disable=SC2154
				die 'no cached profiles found' $(( exitcode_ERROR_NOT_FOUND ))
				# ...bc it's defined in a library
			fi
			# shellcheck disable=SC2154
			exit $(( exitcode_OK ))
			# ...bc it's defined in a library
		;;

		'status')
			case "${2-}" in
				'')
					print_script_version
					print_status
				;;

				'-j'|'--json')
					# {"profile": "10", "tuned_profile": [9, 10, 11]}
					active_profile="$( get_active_profile_id )"
					# shellcheck disable=SC2207
					# ...bc care is taken to have word splitting work the right way + way simplier error handling
					cached_profiles_array=( $( get_cached_profiles_ids ) )
					echo "{\"profile\": \"${active_profile:--1}\", \"tuned_profile\": [$( print_array_comma_separated 'cached_profiles_array' )]}"
					#                                       -1 for factory default profile (no profile at all)
				;;

				'-d'|'--active-profile-desc')
					get_active_profile_description
				;;

				'-i'|'--active-profile-id')
					get_active_profile_id
				;;

				'-l'|'--cached-profiles-list')
					get_cached_profiles_ids
				;;

				*)
					print_script_version
					print_script_usage
					echo "invalid option '$2'"
					false # set exitcode for 'exit'
				;;
			esac
			exit
		;;

		'retune'|'re-tune')
			if [[ "${@:2}" == "full" ]]; then
				oc_retune_full=1
			fi
			(( oc_action = oc_action_RETUNE ))
		;;

		'finetune')
			(( oc_action = oc_action_FINETUNE ))
		;;

		'default'|'factory')
			(( oc_action = oc_action_FACTORY ))
		;;

		'-h'|'--help'|'')
			print_script_version
			print_script_usage
			exit
		;;

		*)
			(( oc_action = oc_action_APPLY_OC ))
			[[ "${2-}" == '-f' || "${2-}" == '--force' ]] && forced_apply_incoming_profile_FLAG=1
		;;
	esac
}


#
# logic
#

function is_series_17 {
	# code
	[[ "$ASIC_MODEL" == 'Antminer S17'* || "$ASIC_MODEL" == 'Antminer T17'* ]]
}

function is_series_19 {
	# code
	[[ "$ASIC_MODEL" == 'Antminer S19'* || "$ASIC_MODEL" == 'Antminer T19'* ]]
}

function is_profile_cached {
	# args
	(( $# == 1 )) || return 1
	local -r profile_id="$1"

	# vars
	local cached_profile_filename

	# code
	cached_profile_filename="$( get_cached_profile_filename "$profile_id" )"
	[[ -s "$cached_profile_filename" ]]
}


#
# getters: active profile
#

function get_active_profile_id {
	# code
	if [[ -s "$active_profile_file_w_path" ]]; then
		if is_series_17 || is_series_19; then
			read_variable_from_file "$active_profile_file_w_path" 'tune_profile'
		else
			read_variable_from_file <( replace_ampersands_with_newlines < "$active_profile_file_w_path" ) 'profile'
		fi
	else
		return $(( exitcode_ERROR_NOT_FOUND ))
	fi
}

function get_active_profile_description {
	# vars
	local active_profile_id active_profile_description

	# code
	if active_profile_id="$( get_active_profile_id )"; then
		active_profile_description="$( get_description_for_profile "$active_profile_id" || echo "Profile #$active_profile_id" )"
	else
		active_profile_description='factory'
	fi
	echo "$active_profile_description"
}


#
# getters: description
#

function get_description_for_profile {
	# args
	(( $# == 1 )) || return 1
	local -r -i profile_id="$1"

	# vars
	local ASIC_MODEL_short _ASIC_CUSTOM_FW_VERSION profile_description_file

	# code
	ASIC_MODEL_short="$( cut -d' ' -f2 <<< "$ASIC_MODEL" )"
	_ASIC_CUSTOM_FW_VERSION="${ASIC_CUSTOM_FW_VERSION:-1.00}" # 1.00 if empty

	profile_description_file="/hive/share/profiles/${ASIC_MODEL_short}_${_ASIC_CUSTOM_FW_VERSION}_description"
	read_variable_from_file "$profile_description_file" "profile_$profile_id"
}


#
# getters: cached profiles
#

function get_cached_profile_filename {
	# args
	(( $# == 1 )) || return 1
	local -r profile_id="$1"

	# code
	if is_series_17; then
		echo "${cached_profiles_directory}/${profile_id}/$ant17_profile_filename"
	elif is_series_19; then
		echo "${cached_profiles_directory}/${profile_id}/$ant19_profile_filename"
	else
		echo "${cached_profiles_directory}/${profile_id}/$ant9_profile_filename"
	fi
}

function get_cached_profiles_ids {
	# vars
	local this_profile_directory

	# code
	if [[ -d "$cached_profiles_directory" ]]; then
		# more accurate option would be like: shopt -s extglob; for i in "$cached_profiles_directory"/+([0-9])/
		for this_profile_directory in "$cached_profiles_directory"/[0-9]/ "$cached_profiles_directory"/[0-9][0-9]*/; do
		#                                                          ^^^^^                               ^^^^^^^^^^^
		# kind of a version sort: first go one-figure numbers, second go two-or-more-figure numbers
			if [[ -s "${this_profile_directory}${active_profile_filename}" ]]; then
				#[[ "$this_profile_directory" =~ /([0-9]+)/$ ]] && echo "${BASH_REMATCH[1]}"
				# matching is slower by 15-20%, so we'd fancy this:
				: "${this_profile_directory%/*}" # cut the final '/'
				echo "${_##*/}" # cut all before last slash (including slash)
			fi
		done
	else
		return $(( exitcode_ERROR_NOT_FOUND ))
	fi
}

function get_cached_profile {
	# args
	(( $# == 1 )) || return 1
	local -r profile_id="$1"

	# var
	local cached_profile_filename

	# code
	cached_profile_filename="$( get_cached_profile_filename "$profile_id" )"
	if [[ -s "$cached_profile_filename" ]]; then
		if is_series_17 || is_series_19; then
			cat "$cached_profile_filename"
		else
			replace_ampersands_with_newlines < "$cached_profile_filename"
		fi
	fi
}

function clear_cached_profile {
	#
	# Usage: clear_cached_profile ALL|profile_id...
	#

	# args
	(( $# > 0 )) || return 1
	local -r -a profiles_to_clear=( "$@" )

	# var
	local this_profile

	# code
	if [[ "${profiles_to_clear[0]}" == 'ALL' ]]; then
		# do clear all cached profiles
		echo -n '> Clearing cache for all profiles... '
		if rm -r "${cached_profiles_directory:-SAFE}" > /dev/null 2>&1; then
			echo 'OK'
		else
			echo 'FAIL'
			# shellcheck disable=SC2154
			die 'cache clearing error' $(( exitcode_ERROR_SOMETHING_WEIRD ))
			# ...bc it's defined in a library
		fi
	else
		# do clear only selected profile(s)
		for this_profile in "${profiles_to_clear[@]}"; do
			if is_integer "$this_profile"; then
				echo -n "> Clearing cache for profile #$this_profile... "
				if rm -r "${cached_profiles_directory:-SAFE}/$this_profile" > /dev/null 2>&1; then
					echo 'OK'
				else
					echo 'FAIL'
				fi
			else
				die "invalid profile ID '$this_profile' (not an integer number)" $(( exitcode_ERROR_SOMETHING_WEIRD ))
			fi
		done
	fi
}


#
# getters: json
#

function get_profile_id_from_json {
	# args
	(( $# == 1 )) || return 1
	local -r input_json="$1"

	# vars
	local profile_id

	# code
	if profile_id="$( jq --exit-status --raw-output 'if .tune_profile then .tune_profile else .profile end' <<< "$input_json" 2> /dev/null )" && [[ "$profile_id" != 'null' ]]; then
		if is_integer "$profile_id"; then
			echo "$profile_id"
		else
			(( script_DEBUG )) && errcho "profile_id '$profile_id' is not integer in JSON '$input_json'"
			return $(( exitcode_ERROR_NOT_FOUND ))
		fi
	else
		(( script_DEBUG )) && errcho "jq error in JSON '$input_json'"
		return $(( exitcode_ERROR_NOT_FOUND ))
	fi
}

function get_key_value_pairs_from_json {
	# args
	(( $# == 1 )) || return 1
	local -r input_json="$1"

	# consts
	local -r jq_key_value='. | with_entries( select( .key != "desc" ) ) | to_entries[] | "\(.key)=\(.value)"' # filter out a description field -- auto-tune doesn't need this and a subsequent parsing can be complicated, then

	# vars
	local valid_json # this var name isn't accurate enough

	# code
	if valid_json="$( jq --raw-output "$jq_key_value" <<< "$input_json" 2> /dev/null )" && [[ -n "$valid_json" ]]; then
		echo "$valid_json"
	else
		(( script_DEBUG )) && errcho "jq error in JSON '$input_json'"
		return $(( exitcode_ERROR_NOT_FOUND ))
	fi
}


#
# setters
#

function set_model_dependent_variables {
	# code
	if is_series_17; then
		active_profile_filename="$ant17_profile_filename"
		tune_files_collection=( "${ant17_tune_files_collection[@]}" )
		profile_files_collection=( "${ant17_profile_files_collection[@]}" )
	elif is_series_19; then
		active_profile_filename="$ant19_profile_filename"
		tune_files_collection=( "${ant19_tune_files_collection[@]}" )
		profile_files_collection=( "${ant19_profile_files_collection[@]}" )
	else
		active_profile_filename="$ant9_profile_filename"
		tune_files_collection=( "${ant9_tune_files_collection[@]}" )
		profile_files_collection=( "${ant9_profile_files_collection[@]}" )
	fi

	active_profile_file_w_path="$active_profile_directory/$active_profile_filename"
}


#
# save/restore profile to/from cache
#

function save_active_profile_to_cache {
	# vars
	local active_profile_id directory_to_save
	local this_file source_file destination_file
	local -i is_something_cached_FLAG=0

	# code
	# is active profile exist? is there a profile ID?
	if [[ -s "$active_profile_file_w_path" ]] && active_profile_id="$( get_active_profile_id )"; then
		: ok good to go
	else
		return $(( exitcode_ERROR_NOT_FOUND ))
	fi

	echo "> Saving active profile #$active_profile_id to cache..."

	directory_to_save="${cached_profiles_directory}/${active_profile_id}"
	mkdir -p "$directory_to_save"

	for this_file in "${profile_files_collection[@]}"; do
		source_file="$active_profile_directory/$this_file"
		destination_file="$directory_to_save/$this_file"
		if [[ -s "$source_file" ]]; then
			(( script_DEBUG )) && echo -n "  [DEBUG] updating $source_file to $directory_to_save/... "
			# like cp --update option: if destination file isn't exist, or empty, or older
			if [[ ! -s "$destination_file" || "$source_file" -nt "$destination_file" ]]; then
				# cp -p: preserve timestamp
				if cp -pf "$source_file" "$destination_file"; then
					(( script_DEBUG )) && echo 'OK'
					is_something_cached_FLAG=1
				fi
			else
				if (( script_DEBUG )); then
					echo -n 'Skipped, '
					diff "$source_file" "$destination_file" > /dev/null && echo 'files are equal' || echo 'BUT files are different!'
				fi
			fi
		else
			# if source file doesn't exist, we don't need it as at destination too
			if [[ -s "$destination_file" ]] && rm "$destination_file"; then
				(( script_DEBUG )) && echo "  [DEBUG] $source_file doesn't exist, delete corresponding $destination_file"
				is_something_cached_FLAG=1
			fi
		fi
	done

	(( is_something_cached_FLAG )) && echo "  Active profile #$active_profile_id cached for later use"

	return $(( is_something_cached_FLAG ))
}

function restore_cached_profile {
	# args
	(( $# == 1 )) || return 1
	local -r profile_id="$1"

	# REs
	local -r hiveon_freq_and_voltage_RE='^bitmain-freq|^bitmain-voltage'

	# vars
	local this_file source_file destination_file
	local fv_settings_from_source_config non_fv_settings_from_destination_config
	local -i is_something_restored_FLAG=0

	# code
	echo "> Restoring profile #$profile_id..."

	for this_file in "${profile_files_collection[@]}"; do
		source_file="$cached_profiles_directory/$profile_id/$this_file"
		destination_file="$active_profile_directory/$this_file"
		if [[ -s "$source_file" ]]; then
			if [[ "$this_file" == "$hiveon_config_file" ]]; then
				# get hashboard freq/voltage settings from cached hiveon config and then paste them in the current hiveon config
				# NOTE: the other settings in the current config should be left intact
				if fv_settings_from_source_config="$( grep -E "$hiveon_freq_and_voltage_RE" "$source_file" | sort )" && [[ -n "$fv_settings_from_source_config" ]]; then
					(( script_DEBUG )) && echo "  [DEBUG] getting freq/voltage settings from $source_file..."
					if non_fv_settings_from_destination_config="$( grep -v -E "$hiveon_freq_and_voltage_RE" "$destination_file" )" && [[ -n "$non_fv_settings_from_destination_config" ]]; then
						cp -p "$destination_file" "$destination_file.previous" # for emergencies
						(( script_DEBUG )) && echo "  [DEBUG] pasting freq/voltage settings to $destination_file..."
						printf '%s\n%s\n' "$fv_settings_from_source_config" "$non_fv_settings_from_destination_config" > "$destination_file"
					else
						(( script_DEBUG )) && echo "  [DEBUG] there are no any settings in $destination_file. Weird, eh..."
					fi
				else
					(( script_DEBUG )) && echo "  [DEBUG] there are no freq/voltage settings in $source_file. Weird, eh..."
				fi
			else
				# cp -p: preserve timestamp
				if cp -pf "$source_file" "$destination_file"; then
					(( script_DEBUG )) && echo "  [DEBUG] copying $source_file to $active_profile_directory/..."
					is_something_restored_FLAG=1
				fi
			fi
		else
			# if source is not exist, but destination is -- delete destination then
			if [[ -s "$destination_file" ]]; then
				if rm "$destination_file"; then
					(( script_DEBUG )) && echo "  [DEBUG] deleting $destination_file..."
					is_something_restored_FLAG=1
				fi
			fi
		fi
	done

	(( is_something_restored_FLAG )) && echo "  Profile #$profile_id restored from cache"

	return $(( is_something_restored_FLAG ))
}

function deactivate_active_files {
	# args
	(( $# > 0 )) || return 1

	# vars
	local this_file this_file_w_path

	# code
	echo '> Deactivating auto-tune files...'
	for this_file in "$@"; do
		this_file_w_path="$active_profile_directory/$this_file"
		echo -n "  [DEBUG] $this_file_w_path "
		if [[ -f "$this_file_w_path" ]]; then
			if [[ "$this_file" == "$hiveon_config_file" ]] && (( oc_retune_full==0 )); then
				# some sort of a kludge for L3+ Hiveon 1.02 (and the others, maybe)
				# leave an original config.conf because it's crucial to leave it be
				cp "$this_file_w_path" "$this_file_w_path.previous" && echo 'OK (copied to *.previous)' || echo 'FAIL (copy error)'
			else
				mv -f "$this_file_w_path" "$this_file_w_path.previous" && echo 'OK (renamed to *.previous)' || echo 'FAIL (rename error)'
			fi
		else
			echo 'SKIPPED (not exist)'
		fi
	done
}

function deactivate_active_profile_files {
	# wrapper
	deactivate_active_files "${profile_files_collection[@]}"
}

function deactivate_active_tune_files {
	# wrapper
	deactivate_active_files "${tune_files_collection[@]}"
}


#
# print_status()
#

function print_status {
	# dictionaries
	local -r -a tune_status_dictionary=(
		[tune_status_NOT_YET]='not yet tuned'
		[tune_status_TUNING]='tuning unfinished'
		[tune_status_DONE]='tuned'
		[tune_status_ERROR]='tune status error'
		[tune_status_NOT_SUPPORTED]='tune status not supported'
	)

	# vars
	local -a profile_description_array=() profile_tune_status_array=() is_profile_cached_array=()
	local this_profile_id
	local active_profile_id=-1 active_profile_description='' active_profile_tune_status="$tune_status_NOT_SUPPORTED"
	local marker_active marker_tune_status marker_cached

	# code
	for this_profile_id in $( get_cached_profiles_ids ); do
		profile_description_array[$this_profile_id]="$( get_description_for_profile "$this_profile_id" || echo "Profile #$this_profile_id" )"
		profile_tune_status_array[$this_profile_id]="$(
			read_variable_from_file "$( get_cached_profile_filename "$this_profile_id" )" 'tune_status' ||
				echo "$tune_status_NOT_SUPPORTED"
		)"
		is_profile_cached_array[$this_profile_id]=1
	done

	echo -n "  $ASIC_MODEL"
	(( IS_ASIC_CUSTOM_FW )) && echo " @ $ASIC_CUSTOM_FW_VERSION"
	echo

	if [[ -s "$active_profile_file_w_path" ]]; then
		if active_profile_id="$( get_active_profile_id )"; then
			active_profile_description="$( get_description_for_profile "$active_profile_id" || echo "Profile #$active_profile_id" )"
			active_profile_tune_status="$(
				read_variable_from_file "$active_profile_file_w_path" 'tune_status' || echo "$tune_status_NOT_SUPPORTED"
			)"
			profile_description_array[$active_profile_id]="$active_profile_description"
		else
			errcho "$active_profile_file_w_path does exist but has no profile ID"
			(( ${#is_profile_cached_array[@]} > 0 )) && { echo; echo '  Cached profiles:'; }
			echo
		fi
	else
		echo -n '  Running on factory settings'
		if (( ${#is_profile_cached_array[@]} > 0 )); then
			echo '. Cached profiles:'
		else
			echo '. No cached profiles found.'
		fi
		echo
	fi

	for this_profile_id in "${!profile_description_array[@]}"; do
		marker_active=''
		marker_tune_status=''
		marker_cached='not cached yet'

		if (( this_profile_id == active_profile_id )); then
			marker_active='>'
			marker_tune_status="${tune_status_dictionary[$active_profile_tune_status]}"
		else
			marker_tune_status="${tune_status_dictionary[${profile_tune_status_array[$this_profile_id]}]}"
		fi
		[[ -n "${is_profile_cached_array[this_profile_id]-}" ]] && marker_cached='cached'
		printf '%1.1s %3d. %16.16s (%s, %s)\n' "$marker_active" "$this_profile_id" "${profile_description_array[this_profile_id]}" "$marker_cached" "$marker_tune_status"
	done
	echo
}


#
# profiles comparing
#

function load_profile_to_array {
	# args
	(( $# == 2 )) || return 1
	local -r profile_to_load="$1"
	local -r array_name="$2"

	# consts
	local -r -n array_to_save="$array_name"
	local -r parameters_to_ignore='^(profile|tune_max_restarts|tune_uptime)$'

	# vars
	local parameter value
	local -i loaded_parameters_counter=0 total_parameters_counter=0

	# code

	if [[ -n "$profile_to_load" ]]; then
		# load var=val to hashtable
		while IFS='=' read -r 'parameter' 'value' || [[ -n "$parameter" ]]; do
			if [[ ! "$parameter" =~ $parameters_to_ignore ]]; then
				# shellcheck disable=SC2034
				# ...bc of indirect 'local -n'
				array_to_save["$parameter"]="$value"
				#keys_hashtable["$parameter"]=1 # united hashtable with keys from both arrays, unnecessary atm
				(( loaded_parameters_counter++ ))
			fi
			(( total_parameters_counter++ ))
		done <<< "$profile_to_load"
		(( script_DEBUG )) && echo "  [DEBUG] loaded $loaded_parameters_counter/$total_parameters_counter parameters to ${array_name}[]"
	else
		return 1
	fi
}

function is_cached_profile_equal_to_incoming {
	# vars
	local this_key incoming_value cached_value

	# code
	for this_key in "${!incoming_profile_as_hashtable[@]}"; do
		incoming_value="${incoming_profile_as_hashtable[$this_key]}"
		cached_value="${cached_profile_as_hashtable[$this_key]-}"
		if [[ "$incoming_value" != "$cached_value" ]]; then
			return 1
		fi
	done
}

function print_differencies_in_profiles {
	# consts
	local -r -n keys='incoming_profile_as_hashtable'

	# vars
	local this_key incoming_value cached_value this_color

	# code
	echo
	printf '%-27.27s %7.7s %8.8s\n' 'parameter' 'cached' 'updated'
	echo '-------------------------------------------'
	for this_key in "${!keys[@]}"; do
		incoming_value="${incoming_profile_as_hashtable[$this_key]:--}"
		cached_value="${cached_profile_as_hashtable[$this_key]:--}"
		if [[ "$incoming_value" != "$cached_value" ]]; then
			this_color="${BYELLOW}"
		else
			this_color="${GREEN}"
		fi
		printf '%-27.27s %b%7.7s %8.8s%b\n' "$this_key" "$this_color" "$cached_value" "$incoming_value" "${NOCOLOR}"
	done | sort
	echo
}


#
# model-dependent tune & restart
#

function delete_tune_logs {
	#
	# delete log(s) from previous session
	#

	# consts
	local -r autotune_log='/tmp/auto-tune'
	local -r autotune_L3_new_log='/tmp/log'

	# vars
	local this_log

	# code
	for this_log in "$autotune_log" "$autotune_L3_new_log"; do
		[[ -f "$this_log" ]] && rm "$this_log"
	done
}

function print_tune_logs {
	#
	# try to print every possible auto-tune log
	#

	# consts
	local -r autotune_log='/tmp/auto-tune'
	local -r autotune_L3_new_log='/tmp/log'

	# flags
	local -i is_autotune_log_empty_FLAG=1

	# code
	if [[ -s "$autotune_log" ]]; then
		is_autotune_log_empty_FLAG=0
		echo '> Auto-tune log:'
		cat "$autotune_log"
		echo
	fi
	
	if [[ -s "$autotune_L3_new_log" ]]; then
		is_autotune_log_empty_FLAG=0
		echo '> Auto-tune log (L3+ 1.02):'
		cat "$autotune_L3_new_log"
		echo
	fi

	if [[ -s '/var/log/messages' || -s '/var/log/messages.0' ]]; then
		is_autotune_log_empty_FLAG=0
		echo '> Auto-tune log (L3+ 1.03):'
		echo '! Also could contain old records from previous auto-tune sessions:'
		grep -F 'auto-tune' /var/log/messages.0 /var/log/messages 2> /dev/null
		echo
	fi
	
	if (( is_autotune_log_empty_FLAG )); then
		(( script_DEBUG )) && echo "  [DEBUG] auto-tune log is empty or not found"
	fi
}

# Antminer Series 9 (and the other similar like T9+ and S10)

function kill_autotune_9 {
	#
	# kills the whole tuning stuff
	#

	# vars
	local this_process
	local -i kill_counter

	# code
	(( script_DEBUG )) && echo '> [DEBUG] Stopping all auto-tune processes...'
	for this_process in 'auto-tune' 'tune-yellow' 'auto-chip-tune' 'auto-tune-chains'; do
		kill_counter=0
		while is_process_running "$this_process"; do
			if (( ++kill_counter > 10 )); then
				(( script_DEBUG )) && echo "  [DEBUG] $this_process is still alive after $kill_counter tries!"
				break
			fi
			(( script_DEBUG )) && echo "  [DEBUG] killing $this_process, attempt #$kill_counter"
			killall -q "$this_process"
			snore 0.5
		done
	done
}

function generate_active_profile_9 {
	echo '> Generating active profile for Series 9...'
	# build a fresh config file for auto-tune
	(( script_DEBUG )) && { echo "[DEBUG] incoming profile as key=value: [$incoming_profile_as_key_value_pairs]"; echo; }
	printf '%s' "$incoming_profile_as_key_value_pairs" |
		replace_newlines_with_ampersands > "$active_profile_file_w_path"
	(( script_DEBUG )) && { echo "[DEBUG] generated file: [$( cat "$active_profile_file_w_path" )]"; echo; }
}

function restart_miner_9 {
	# consts
	local -r restart_miner_FILE="$active_profile_directory/restart"
	local -r restart_miner_command='ok'

	# code
	kill_autotune_9
	echo '> Restarting miner...'

	if [[ "$ASIC_MODEL" == 'Antminer L3'* ]]; then
		killall -9 cgminer
		return
	fi

	if ! echo "$restart_miner_command" > "$restart_miner_FILE"; then
		echo "  [ERROR] couldn't create $restart_miner_FILE"
	else
		if (( is_lighttpd_not_running_as_root_FLAG )); then
			if ! chown "$lighttpd_owner:$lighttpd_owner" "$restart_miner_FILE" > /dev/null 2>&1; then
				echo "  [ERROR] couldn't chown $restart_miner_FILE as '$lighttpd_owner'"
			fi
		fi
	fi
}

function tune_9 {
	# consts
	local -r autotune_debug_log='/tmp/auto-tune.nohup.log'

	# code
	kill_autotune_9
	echo '> Auto-tune started...'

	delete_tune_logs

	echo '> 1st phase started...'
	if (( is_lighttpd_not_running_as_root_FLAG )); then
		#																		not tested  vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
		nohup su - "$lighttpd_owner" -c '/usr/bin/auto-tune' > "$autotune_debug_log" 2>&1 # || tune_result_exitcode=exitcode_ERROR_SOMETHING_WEIRD
	else
		#											not tested  vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
		nohup /usr/bin/auto-tune > "$autotune_debug_log" 2>&1 # || tune_result_exitcode=exitcode_ERROR_SOMETHING_WEIRD
	fi
	echo '> 1st phase finished'

	if (( script_DEBUG )); then
		if [[ ! -f "$active_hiveon_config_file" ]]; then
			echo "  [DEBUG] $active_hiveon_config_file not found (but it has to be)" # ??? do we still need this
		fi
		if [[ -f "$autotune_debug_log" ]]; then
			echo '> [DEBUG] Auto-tune log:'
			cat "$autotune_debug_log"
			echo
			rm "$autotune_debug_log"
		fi
	fi

	print_tune_logs

	if grep -q 'enable_auto_chip=1' "$active_profile_file_w_path"; then
		echo '> 2nd phase started and will be continued in the background...'
		if (( is_lighttpd_not_running_as_root_FLAG )); then
			nohup su - "$lighttpd_owner" -c '/usr/bin/auto-chip-tune' > /dev/null 2>&1 & disown
		else
			nohup /usr/bin/auto-chip-tune > /dev/null 2>&1 & disown
		fi
	fi
	echo '> Auto-tune finished'
}

function fix_autotune_bugs_9 {
	#
	# fixes for $active_hiveon_config_file:
	# 1. remove all empty lines
	# 2. delete if empty
	#

	# code
	# shellcheck disable=SC2154
	# ...bc defined in the library
	if is_file_exist_and_contain "$active_hiveon_config_file" "$empty_line_RE"; then
		(( script_DEBUG )) && echo "  [DEBUG] $active_hiveon_config_file contains empty lines, deleting them"
		sed -i "/$empty_line_RE/d" "$active_hiveon_config_file" # > /dev/null 2>&1
	fi

	if is_file_exist_but_empty "$active_hiveon_config_file"; then
		(( script_DEBUG )) && echo "  [DEBUG] Empty $active_hiveon_config_file, removing the file"
		rm "$active_hiveon_config_file"
	fi
}

# Antminer L3+/L3++

function generate_active_profile_L3 {
	echo '> Generating active profile for L3+/L3++...'
	# build a fresh config file for auto-tune
	(( script_DEBUG )) && { echo "[DEBUG] incoming profile as key=value: [$incoming_profile_as_key_value_pairs]"; echo; }
	{
		printf '%s' "$incoming_profile_as_key_value_pairs"
		if ! grep -Eq -e '^total_hw_rate_threshold=[0-9.]+$' <<< "$incoming_profile_as_key_value_pairs"; then
			# a kind of rude temporary fix for L3+ 1.02/1.03
			printf '\n'
			printf '%s\n'	'hw_per_minute_avg_threshold=20'
			printf '%s\n'	'wait_after_restart=100'
			printf '%s\n'	'wait_test_run_seconds=360'
			printf '%s\n'	'stat_poll_interval=30'
			printf '%s\n'	'hw_freq_step=4'
			printf '%s\n'	'hw_threshold_value=5'
			printf '%s\n'	'max_restarts=15'
			printf '%s\n'	'hw_wait_on_start=180'
			printf '%s'		'total_hw_rate_threshold=0.1'
		fi
	} | replace_newlines_with_ampersands > "$active_profile_file_w_path"
	(( script_DEBUG )) && { echo "[DEBUG] generated file: [$( cat "$active_profile_file_w_path" )]"; echo; }
}

function tune_L3 {
	# consts
	local -r autotune_debug_log='/tmp/auto-tune.nohup.log'

	# code
	kill_autotune_9
	echo '> Auto-tune started...'

	delete_tune_logs

	echo '> 1st phase started...'
	if ! nohup /usr/bin/auto-tune-chains > "$autotune_debug_log" 2>&1; then
		echo '  [ERROR] auto-tune-chains failed'
		tune_result_exitcode=exitcode_ERROR_SOMETHING_WEIRD
	fi

	snore 1

	echo '> 2nd phase started...'
	if ! nohup /usr/bin/auto-tune >> "$autotune_debug_log" 2>&1; then
		echo '  [ERROR] auto-tune failed'
		tune_result_exitcode=exitcode_ERROR_SOMETHING_WEIRD
	fi

	if (( script_DEBUG )); then
		if [[ ! -f "$active_hiveon_config_file" ]]; then
			echo "  [DEBUG] $active_hiveon_config_file not found (but it has to be)" # ??? do we still need this
		fi
		if [[ -f "$autotune_debug_log" ]]; then
			echo '> [DEBUG] Auto-tune log:'
			cat "$autotune_debug_log"
			echo
			rm "$autotune_debug_log"
		fi
	fi

	print_tune_logs

	if (( tune_result_exitcode == exitcode_OK )); then
		echo '> Auto-tune finished'
	else
		echo '> Auto-tune FAILED'
	fi
}

# Antminer Series 17

function generate_active_profile_17 {
	echo '> Generating active profile (Series 17)...'
	# build a fresh config file for auto-tune
	{
		if ! grep -Eq -e '^tune_profile=[0-9]+$' <<< "$incoming_profile_as_key_value_pairs"; then
			echo "tune_profile=$incoming_profile_id"
		fi
		echo 'tune_status=0'
		echo 'tune_max_restarts=10'
		echo 'tune_uptime=240'
		echo "$incoming_profile_as_key_value_pairs"
	} > "$active_profile_file_w_path"
}

function restart_miner_17_old {
	# code
	echo '> Restarting miner (Series 17 old method)...'
	killall bmminer
}

function restart_miner_17_new {
	# code
	echo '> Restarting miner (Series 17 new method)...'
	echo '1' > /tmp/reopen # Hiveon 2.03+
}

function tune_17_old {
	# vars
	local -i minutes_counter=0

	# code
	echo '> Auto-tune started (Series 17 old method)...'
	until tune_status="$( read_variable_from_file "$active_profile_file_w_path" 'tune_status' )" && (( tune_status == tune_status_DONE )); do
		if (( ++minutes_counter == 200 )); then
			# forcibly stop tuning after 200 minutes
			set_variable_in_file "$active_profile_file_w_path" 'tune_status' "$tune_status_DONE"
			miner restart
		fi
		snore 60
	done
	echo '> Auto-tune finished'
	printf '<h3>\nTune log</h3>'
	miner tuning
}

function tune_17_new {
	# vars
	local -i minutes_counter

	# code
	echo '> Auto-tune started (Series 17 new method)...'
	# wait for 500 minutes (usually it takes like 30-40 minutes)
	for (( minutes_counter=0; minutes_counter < 500; minutes_counter++ )); do
		snore 60
		if tune_status="$( read_variable_from_file "$active_profile_file_w_path" 'tune_status' )" && (( tune_status == tune_status_DONE )); then
			echo '> Auto-tune finished'
			printf '<h3>\nTune log</h3>'
			miner tuning
			break
		fi
	done
}

# Antminer Series 19

function generate_active_profile_19 { #TODO set tune_status, tune_max_restarts, tune_uptime via Hive dashboard?
	echo '> Generating active profile (Series 19)...'
	# build a fresh config file for auto-tune
	{
		if ! grep -Eq -e '^tune_profile=[0-9]+$' <<< "$incoming_profile_as_key_value_pairs"; then
			echo "tune_profile=$incoming_profile_id"
		fi
		echo 'tune_status=0'
		echo 'tune_max_restarts=10'
		echo 'tune_uptime=240'
		echo "$incoming_profile_as_key_value_pairs"
	} > "$active_profile_file_w_path"
}

function restart_miner_19 {
	# code
	echo '> Restarting miner (Series 19)...'
	echo '1' > /tmp/reopen
}


#
# lighttpd ownership
#

function get_lighttpd_owner {
	# code
	get_process_owner 'lighttpd'
}

function is_lighttpd_not_running_as_root {
	# code
	lighttpd_owner="$( get_lighttpd_owner )" # global var
	[[ -n "$lighttpd_owner" && "$lighttpd_owner" != 'root' ]]
}

function fix_tune_files_ownership {
	#
	# fix tune files ownership for CGI scripts
	#

	# vars
	local this_file this_file_w_path

	# code
	if [[ -n "$lighttpd_owner" ]]; then
		echo "> Fixing profile ownership for '$lighttpd_owner'..."
		for this_file in "${profile_files_collection[@]}" /tmp/auto-tune; do
			#                                             ^^^^^^^^^^^^^^ non-root auto-tune process cannot write to this log until its UID becomes a non-root too
			#
			# check if $this_file is a "fully-qualified" filename with path
			if [[ "$this_file" =~ ^[/.~] ]]; then
				this_file_w_path="$this_file"
			else
				this_file_w_path="$active_profile_directory/$this_file"
			fi
			(( script_DEBUG )) && echo -n "  [DEBUG] $this_file_w_path "
			if [[ -f "$this_file_w_path" ]]; then
				if chown "$lighttpd_owner:$lighttpd_owner" "$this_file_w_path" > /dev/null 2>&1; then
					(( script_DEBUG )) && echo 'OK'
				else
					(( script_DEBUG )) && echo 'FAIL'
				fi
			else
				(( script_DEBUG )) && echo 'SKIPPED (not exist)'
			fi
		done
	fi
}


#
# auxillary functions
#

function print_array_comma_separated {
	# args
	(( $# == 1 )) || return 1
	local -n -r array_to_print="${1-}"

	# vars
	local IFS

	# code
	if [[ -n "${array_to_print[*]-}" ]]; then
		IFS=','
		echo "${array_to_print[*]}"
	fi
}

function replace_newlines_with_ampersands {
	# code
	# alternative: sed ':a;N;$!ba;s/\n/\&/g'
	tr '\n' '&'
}

function replace_ampersands_with_newlines {
	# code
	# alternative: sed 's|&|\n|g'
	tr '&' '\n'
}

function print_all_variables_in_file { # NOT USED ATM, should one carry it over to the library?
	#
	# Usage: print_all_variables_in_file 'file'
	#

	# code
	(( $# == 1 )) || return 1
	local -r file="$1"
	grep -Ee '^[_[:alnum:]]+=[^[:space:]]' -- "$file"
}


#
# functions END
#


# sources

source /hive/bin/colors				|| echo 'ERROR: /hive/bin/colors not found'
source /hive/bin/asic-model			|| die '/hive/bin/asic-model not found'
source /hive/bin/hive-functions.sh	|| die '/hive/bin/hive-functions.sh not found'


# consts

declare -r active_profile_directory='/config'
declare -r cached_profiles_directory='/config/profiles'

declare -r hiveon_config_file='config.conf'
declare -r active_hiveon_config_file="$active_profile_directory/$hiveon_config_file"

declare -r ant17_profile_filename="profile.txt"
declare -r -a ant17_tune_files_collection=( 'manual_freqs.txt' "$hiveon_config_file" )
declare -r -a ant17_profile_files_collection=( "$ant17_profile_filename" "${ant17_tune_files_collection[@]}" )

declare -r ant19_profile_filename="profile.txt"
declare -r -a ant19_tune_files_collection=( 'manual_freqs.txt' "$hiveon_config_file" )
declare -r -a ant19_profile_files_collection=( "$ant19_profile_filename" "${ant19_tune_files_collection[@]}" )

declare -r ant9_profile_filename="autoTune.conf"
declare -r -a ant9_tune_files_collection=( 'manual_freqs.txt' 'yellow-step' "$hiveon_config_file" )
declare -r -a ant9_profile_files_collection=( "$ant9_profile_filename" "${ant9_tune_files_collection[@]}" )


# enums

declare -r -i tune_status_NOT_YET=0
declare -r -i tune_status_TUNING=1
declare -r -i tune_status_DONE=2
declare -r -i tune_status_ERROR=127
declare -r -i tune_status_NOT_SUPPORTED=128

declare -r -i oc_action_FACTORY=1
declare -r -i oc_action_RETUNE=2
declare -r -i oc_action_FINETUNE=3
declare -r -i oc_action_APPLY_OC=4
declare -r -i oc_retune_full=0


# vars

declare active_profile_filename active_profile_file_w_path active_profile_id active_profile_description
declare -a profile_files_collection tune_files_collection
declare incoming_profile_id incoming_profile_description incoming_profile_as_key_value_pairs
declare message_text message_event_type
declare -i oc_action
declare -i have_to_tune_FLAG=0 have_to_restart_miner_FLAG=0 forced_apply_incoming_profile_FLAG=0 have_to_generate_active_profile_FLAG=0
declare -i tune_start_time tune_finish_time
declare -i tune_result_exitcode=exitcode_OK # a global end-to-end exitcode (see the last line of the script) -- used in tune_L3() only (at this moment)
declare -A incoming_profile_as_hashtable cached_profile_as_hashtable # keys_hashtable

declare -i is_lighttpd_not_running_as_root_FLAG=0
declare lighttpd_owner


# main

[[ "$ASIC_MANUFACTURER" == 'Bitmain' ]] || die "$ASIC_MODEL by $ASIC_MANUFACTURER is not supported"

set_variable_to_current_system_time_in_seconds 'tune_start_time' # to time the running time

set_model_dependent_variables

process_arguments "$@" # sets oc_action
print_script_version
save_active_profile_to_cache

if active_profile_id="$( get_active_profile_id )"; then
	active_profile_description="$( get_description_for_profile "$active_profile_id" || echo "Profile #$active_profile_id" )"
else
	active_profile_description='factory'
fi


#
# prepare actions
#

case "$oc_action" in

	"$oc_action_FACTORY")
		echo '<h3>Setting profile to factory defaults</h3>'
		if [[ -s "$active_profile_file_w_path" ]]; then
			message_text="Profile $active_profile_description is OFF. Now running with sub-optimal factory settings"
			#
			have_to_restart_miner_FLAG=1
		else
			message_text='Already running on sub-optimal factory settings'
			#
			have_to_restart_miner_FLAG=0
		fi
		echo "$message_text"
		deactivate_active_profile_files |
			tee >( message 'warning' "$message_text" --payload > /dev/null )
		rm "$active_hiveon_config_file" # !!! might be a controversial issue, but for now -- let it be
		#
		have_to_generate_active_profile_FLAG=0
		have_to_tune_FLAG=0
	;;

	"$oc_action_RETUNE")
		echo '<h3>Re-tuning profile from scratch</h3>'
		if [[ -s "$active_profile_file_w_path" ]]; then
			message_text="Re-tuning $active_profile_description from scratch"
			message_event_type='info'
			is_series_17 || is_series_19 &&
				set_variable_in_file "$active_profile_file_w_path" 'tune_status' "$tune_status_NOT_YET"
			#
			have_to_restart_miner_FLAG=1
			have_to_tune_FLAG=1
		else
			message_text='No active profile found, re-tuning skipped'
			message_event_type='warning'
			#
			have_to_restart_miner_FLAG=0
			have_to_tune_FLAG=0
		fi
		echo "$message_text"
		echo
		deactivate_active_tune_files |
			tee >( message "$message_event_type" "$message_text" --payload > /dev/null )
		#
		have_to_generate_active_profile_FLAG=0
	;;

	"$oc_action_FINETUNE")
		echo '<h3>Fine-tuning profile</h3>'
		if [[ -s "$active_profile_file_w_path" ]]; then
			message_text="Fine-tuning for $active_profile_description is started"
			message_event_type='ok'
			is_series_17 || is_series_19 &&
				set_variable_in_file "$active_profile_file_w_path" 'tune_status' "$tune_status_TUNING"
			#
			have_to_restart_miner_FLAG=1
			have_to_tune_FLAG=1
		else
			message_text='No active profile found, fine-tuning skipped'
			message_event_type='warning'
			#
			have_to_restart_miner_FLAG=0
			have_to_tune_FLAG=0
		fi
		echo "$message_text"
		message "$message_event_type" "$message_text" > /dev/null
		#
		have_to_generate_active_profile_FLAG=0
	;;

	"$oc_action_APPLY_OC")
		if (( script_DEBUG )); then
			echo -n '[DEBUG] Input JSON: '
			jq --exit-status '.' <<< "$1" && echo '[DEBUG] JSON is valid' || echo '[DEBUG] JSON is NOT valid'
			echo
		fi

		# is it valid JSON?
		if incoming_profile_id="$( get_profile_id_from_json "$1" )"; then
			incoming_profile_description="$( get_description_for_profile "$incoming_profile_id" || echo "Profile #$incoming_profile_id" )"
			incoming_profile_as_key_value_pairs="$( get_key_value_pairs_from_json "$1" )"
		else
			print_script_usage
			die "invalid JSON '$1'" 2
		fi

		message_text="Switching profile from $active_profile_description to $incoming_profile_description"
		echo "<h3>$message_text</h3>"

		if is_profile_cached "$incoming_profile_id" && (( ! forced_apply_incoming_profile_FLAG )); then
			# does cached profile exist (and isn't empty)?
			# ...yes, cached profile does exist
			cached_profile="$( get_cached_profile "$incoming_profile_id" )"
			load_profile_to_array "$incoming_profile_as_key_value_pairs" incoming_profile_as_hashtable || errcho 'incoming_profile_as_hashtable loading error'
			load_profile_to_array "$cached_profile" cached_profile_as_hashtable || errcho 'cached_profile_as_hashtable loading error'
			if is_cached_profile_equal_to_incoming; then
				# does cached profile equal to incoming one?
				# ...yes, it does equal
				if (( active_profile_id != incoming_profile_id )); then
					# does cached profile ID not equal to incoming profile ID?
					# ...does NOT equal. copy cached profile over the active one
					echo "> Cached profile #$incoming_profile_id found. It's equal to incoming. Using cached one."
					message 'info' "$message_text. Cached profile activated, auto-tuning skipped" > /dev/null

					restore_cached_profile "$incoming_profile_id"

					if [[ -s "$active_profile_directory/manual_freqs.txt" ]]; then
						#
						have_to_tune_FLAG=0
					else
						echo "> Chip tuning file (manual_freqs.txt) is missing. Profile has to be tuned."
						message 'warning' 'Cached profile is not fully tuned. Engaging auto-tune...' > /dev/null
						#
						have_to_tune_FLAG=1
					fi
					#
					have_to_generate_active_profile_FLAG=0
					have_to_restart_miner_FLAG=1
					#
				else
					# does cached profile ID not equal to incoming profile ID?
					# ...yes it does, the same ID! do nothing.
					echo "> Cached and incoming profiles are equal and have the same ID. Nothing to do."
					message 'warning' "$message_text. Profiles are the same, any actions skipped" > /dev/null
					#
					have_to_generate_active_profile_FLAG=0
					have_to_restart_miner_FLAG=0
					have_to_tune_FLAG=0
				fi
			else
				# does cached profile equal to incoming one?
				# ...no match, incoming is priority then
				echo "> Cached profile #$incoming_profile_id found. It ISN'T equal to incoming profile. Using incoming one."
				print_differencies_in_profiles |
					tee >(
						message 'warning' "$message_text. Cached profile is outdated. Engaging auto-tune..." --payload > /dev/null
					)
				#
				have_to_generate_active_profile_FLAG=1
				have_to_restart_miner_FLAG=1
				have_to_tune_FLAG=1
			fi
		else
			# does cached profile exist (and isn't empty)?
			# ...no, cached profile does not exist (or --force argument is in use). let's generate a brand new profile.
			if (( forced_apply_incoming_profile_FLAG )); then
				message 'info' "$message_text. Forced apply, ignoring cached data" > /dev/null
			else
				message 'info' "$message_text" > /dev/null
			fi
			#
			have_to_generate_active_profile_FLAG=1
			have_to_restart_miner_FLAG=1
			have_to_tune_FLAG=1
		fi

		if (( have_to_generate_active_profile_FLAG )); then
			deactivate_active_profile_files
		fi
	;;

	*)
		die "OC action '$oc_action' not implemented" 1
		;;

esac


#
# proceed model-dependent actions
#

if [[ "$ASIC_MODEL" == 'Antminer S9'* || "$ASIC_MODEL" == 'Antminer T9'* ]] && is_version "$ASIC_CUSTOM_FW_VERSION" '>=' '1.02'; then

	if (( have_to_generate_active_profile_FLAG )); then
		generate_active_profile_9
	fi

	fix_autotune_bugs_9

	if (( have_to_generate_active_profile_FLAG || have_to_restart_miner_FLAG || have_to_tune_FLAG )) && is_lighttpd_not_running_as_root; then
		is_lighttpd_not_running_as_root_FLAG=1
		#lighttpd_owner="$( get_lighttpd_owner )" # already set in is_lighttpd_not_running_as_root()
		fix_tune_files_ownership
	fi

	if (( have_to_restart_miner_FLAG )); then
		restart_miner_9
	fi

	if (( have_to_tune_FLAG )); then
		tune_9
	fi

elif [[ "$ASIC_MODEL" == 'Antminer L3+'* ]] && is_version "$ASIC_CUSTOM_FW_VERSION" '>=' '1.02'; then

	if (( have_to_generate_active_profile_FLAG )); then
		generate_active_profile_L3
	fi

	fix_autotune_bugs_9

	if (( have_to_restart_miner_FLAG )); then
		restart_miner_9
	fi

	if (( have_to_tune_FLAG )); then
		tune_L3
	fi

elif [[ "$ASIC_MODEL" == 'Antminer S17'* || "$ASIC_MODEL" == 'Antminer T17'* ]]; then

	if (( have_to_generate_active_profile_FLAG )); then
		generate_active_profile_17
	fi

	if (( have_to_restart_miner_FLAG )); then
		if is_version "$ASIC_CUSTOM_FW_VERSION" '>=' '2.03'; then
			restart_miner_17_new
		else
			restart_miner_17_old
		fi
	fi

	if (( have_to_tune_FLAG )); then
		if [[ "$ASIC_CUSTOM_FW_VERSION" == '1.00' ]]; then
			tune_17_old
		else
			tune_17_new 
		fi
	fi

elif [[ "$ASIC_MODEL" == 'Antminer S19'* || "$ASIC_MODEL" == 'Antminer T19'* ]]; then

	if (( have_to_generate_active_profile_FLAG )); then
		generate_active_profile_19
	fi

	if (( have_to_restart_miner_FLAG )); then
		restart_miner_19
	fi

	if (( have_to_tune_FLAG )); then
		tune_17_new
	fi

else
	if (( have_to_generate_active_profile_FLAG )); then
		generate_active_profile_9
	fi

	# fix S9 old fw bug
	if [[ -s /usr/bin/compile_ver && "$ASIC_MODEL" == 'Antminer S9'* ]]; then
		sed -i 's/profile=1\&/profile=1\&slow_freq_start=400\&slow_freq_step=25\&slow_volt_max=840\&/' "$active_profile_file_w_path"
		sed -i 's/profile=2\&/profile=2\&slow_freq_start=400\&slow_freq_step=25\&slow_volt_max=840\&/' "$active_profile_file_w_path"
		sed -i 's/profile=3\&/profile=3\&slow_freq_start=400\&slow_freq_step=50\&slow_volt_max=860\&/' "$active_profile_file_w_path"
		sed -i 's/profile=4\&/profile=4\&slow_freq_start=400\&slow_freq_step=50\&slow_volt_max=870\&/' "$active_profile_file_w_path"
		sed -i 's/profile=5\&/profile=5\&slow_freq_start=450\&slow_freq_step=50\&slow_volt_max=880\&/' "$active_profile_file_w_path"
		sed -i 's/profile=6\&/profile=6\&slow_freq_start=450\&slow_freq_step=50\&slow_volt_max=880\&/' "$active_profile_file_w_path"
		sed -i 's/profile=7\&/profile=7\&slow_freq_start=500\&slow_freq_step=50\&slow_volt_max=890\&/' "$active_profile_file_w_path"
		sed -i 's/profile=8\&/profile=8\&slow_freq_start=600\&slow_freq_step=50\&slow_volt_max=890\&/' "$active_profile_file_w_path"
		sed -i 's/profile=9\&/profile=9\&slow_freq_start=600\&slow_freq_step=50\&slow_volt_max=900\&/' "$active_profile_file_w_path"
		sed -i 's/profile=10\&/profile=10\&slow_freq_start=650\&slow_freq_step=50\&slow_volt_max=910\&/' "$active_profile_file_w_path"
		sed -i 's/profile=11\&/profile=11\&slow_freq_start=650\&slow_freq_step=50\&slow_volt_max=930\&/' "$active_profile_file_w_path"
		sed -i 's/profile=12\&/profile=12\&slow_freq_start=700\&slow_freq_step=50\&slow_volt_max=940\&/' "$active_profile_file_w_path"
		sed -i 's/profile=13\&/profile=13\&slow_freq_start=750\&slow_freq_step=50\&slow_volt_max=950\&/' "$active_profile_file_w_path"

		snore 1
		sed -i 's/wait_after_restart_chip=[0-9]*\&/wait_after_restart_chip=7\&/' "$active_profile_file_w_path"
		snore 1

		conftune="$( < "$active_profile_file_w_path" )"
		case "$conftune" in
			*"profile=1"\&*		)		sed -i 's/voltage_from=[0-9]*\&/voltage_from=800\&/' "$active_profile_file_w_path"		;;
			*"profile=2"\&*		)		sed -i 's/voltage_from=[0-9]*\&/voltage_from=800\&/' "$active_profile_file_w_path"		;;
			*"profile=3"\&*		)		sed -i 's/voltage_from=[0-9]*\&/voltage_from=800\&/' "$active_profile_file_w_path"		;;
			*"profile=4"\&*		)		sed -i 's/voltage_from=[0-9]*\&/voltage_from=800\&/' "$active_profile_file_w_path"		;;
			*"profile=5"\&*		)		sed -i 's/voltage_from=[0-9]*\&/voltage_from=810\&/' "$active_profile_file_w_path"		;;
			*"profile=6"\&*		)		sed -i 's/voltage_from=[0-9]*\&/voltage_from=820\&/' "$active_profile_file_w_path"		;;
			*"profile=7"\&*		)		sed -i 's/voltage_from=[0-9]*\&/voltage_from=820\&/' "$active_profile_file_w_path"		;;
			*"profile=8"\&*		)		sed -i 's/voltage_from=[0-9]*\&/voltage_from=830\&/' "$active_profile_file_w_path"		;;
			*"profile=9"\&*		)		sed -i 's/voltage_from=[0-9]*\&/voltage_from=830\&/' "$active_profile_file_w_path"		;;
			*"profile=10"\&*	)		sed -i 's/voltage_from=[0-9]*\&/voltage_from=840\&/' "$active_profile_file_w_path"		;;
			*"profile=11"\&*	)		sed -i 's/voltage_from=[0-9]*\&/voltage_from=850\&/' "$active_profile_file_w_path"		;;
			*"profile=12"\&*	)		sed -i 's/voltage_from=[0-9]*\&/voltage_from=860\&/' "$active_profile_file_w_path"		;;
			*"profile=13"\&*	)		sed -i 's/voltage_from=[0-9]*\&/voltage_from=870\&/' "$active_profile_file_w_path"		;;
		esac
	fi

	fix_autotune_bugs_9

	if (( have_to_generate_active_profile_FLAG || have_to_restart_miner_FLAG || have_to_tune_FLAG )) && is_lighttpd_not_running_as_root; then
		is_lighttpd_not_running_as_root_FLAG=1
		#lighttpd_owner="$( get_lighttpd_owner )" # already set in is_lighttpd_not_running_as_root()
		fix_tune_files_ownership
	fi

	if (( have_to_restart_miner_FLAG )); then
		restart_miner_9
	fi

	if (( have_to_tune_FLAG )); then
		tune_9
	fi
fi

(( have_to_tune_FLAG )) && save_active_profile_to_cache

set_variable_to_current_system_time_in_seconds 'tune_finish_time'
printf '<h3>\nTotal running time %s</h3>' "$( seconds2dhms $(( tune_finish_time - tune_start_time )) )"

exit $(( tune_result_exitcode ))
